<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="js/rhill-voronoi-core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js" type="text/javascript"></script>

    <div id=container style="width: 100%; height: 100vh">
      <div id="scene" style="
      width: 100%;
      height: 100%">
      </div>

    </div>
		<script>



      const backendless = false;

      
      // Our Javascript will go here.
      const scene = new THREE.Scene();

 
      //Add Renderer
      const renderer = new THREE.WebGLRenderer();
      var container = document.getElementById('scene');
      var w = container.offsetWidth;
      var h = container.offsetHeight;
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);


      //Background

      //cubemap
      scene.background = new THREE.CubeTextureLoader()
      .setPath( 'textures/cubeMaps/' )
      .load( [
        'nx.jpeg',
        'px.jpeg',
        'py.jpeg',
        'ny.jpeg',
        'pz.jpeg',
        'nz.jpeg'
      ] );
      

      //Camera
      const camera = new THREE.PerspectiveCamera( 60, w / h, 0.1, 10000 );
      camera.position.x = 1000;
      camera.position.y = 1000;
      camera.position.z = -500;

      if (backendless === false){
      //controls
        var controls = new THREE.OrbitControls(camera, container);
      }

      //Lights
      const lightAmb = new THREE.AmbientLight( 0x404040, 2.5 ); // soft white light
      // const lightPoint = new THREE.PointLight( 0xffffff, .8, 0, 2 );

      scene.add( lightAmb );




      const lightGeometry = new THREE.SphereGeometry( 5, 32, 16 );
      const lightMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff} );
      // const lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );

      //table lights
      const numLights = 5;
      const lightsDist = 1000

      for (let i = 0; i < numLights; i++) {
        const lightPoint = new THREE.PointLight( 0xffffff, 2.2, 1200, 2 );
        const lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );
        lightPoint.position.set( 300, 600, i*lightsDist-600 );
        lightMesh.position.set( 300, 600, i*lightsDist );
        scene.add( lightMesh );
        scene.add( lightPoint );
      }





      // lightPoint.position.set( 300, 800, 3000 );
      // lightMesh.position.set( 300, 800, 3000 );

      

      //Table
      const tableGeometry = new THREE.BoxGeometry( 600, 100, 4500 );
      const tableCoreGeometry = new THREE.BoxGeometry( 598, 98, 4498 );

      const tableCoreMat = new THREE.MeshPhongMaterial( {color: 0x250b52} );
      const tableMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true} );

      const tableCore = new THREE.Mesh( tableCoreGeometry, tableCoreMat );
      const tableOuter = new THREE.Mesh( tableGeometry, tableCoreMat );

      scene.add( tableOuter, tableCore );

      tableOuter.position.set(300, -50, 2250);
      tableCore.position.set(299, -50, 2249);




      //Pucks
      const puckCylinder = new THREE.CylinderGeometry( 30, 30, 20, 16, 1 );
      const puckCoreCylinder = new THREE.CylinderGeometry( 28, 28, 18, 16, 1 );

      //Red Puck
      const rpMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, wireframe: true} );
      const rpCoreMat = new THREE.MeshPhongMaterial( {color: 0xfc0352} );
      //Create Red Pucks
      var rp1 = new THREE.Group();
      var rp2 = new THREE.Group();
      var rp3 = new THREE.Group();
      var rp4 = new THREE.Group();
      const allRedPucks = [rp1, rp2, rp3, rp4];
      for (let i = 0; i < allRedPucks.length; i++) {
        // allRedPucks[i].add( new THREE.Mesh( puckCylinder, rpMaterial ) );
        allRedPucks[i].add( new THREE.Mesh( puckCoreCylinder, rpCoreMat ) );
      }

        

      //Blue Puck
      const bpMaterial = new THREE.MeshBasicMaterial( {color: 0x03b1fc, wireframe: true} );
      const bpCoreMat = new THREE.MeshPhongMaterial( {color: 0x03b1fc} );
      //create Blue Pucks
      var bp1 = new THREE.Group();
      var bp2 = new THREE.Group();
      var bp3 = new THREE.Group();
      var bp4 = new THREE.Group();
      const allBluePucks = [bp1, bp2, bp3, bp4];
      for (let i = 0; i < allBluePucks.length; i++) {
        // allBluePucks[i].add( new THREE.Mesh( puckCylinder, bpMaterial ) );
        allBluePucks[i].add( new THREE.Mesh( puckCoreCylinder, bpCoreMat ) );
      }

      //bar Chart
      const bpBarWFMaterial = new THREE.MeshBasicMaterial( {color: 0x03b1fc, wireframe: true} );
      const bpBarMat = new THREE.MeshPhongMaterial( {color: 0x03b1fc} );
      const barGeometry = new THREE.BoxGeometry( 200, 1000, 200 );
      const bpBar = new THREE.Mesh( barGeometry, bpBarMat );

      scene.add( bpBar );

      bpBar.position.set(-200, 400, 0);




      const allPucks = allBluePucks.concat(allRedPucks);
      for (let i = 0; i < allPucks.length; i++) {
        scene.add(allPucks[i]);
        allPucks[i].position.set(10000, 0, 0);
      }




      //Lines
      const scoreLines = [60,165,524,1054,1768,2762]; // y value of lines
      const lineGeometries = [];
      for (let i = 0; i < scoreLines.length; i++) {
        const points = [];
        const lineY = scoreLines[i];
        points.push( new THREE.Vector3( 0, 1, lineY ) );
        points.push( new THREE.Vector3( 600, 1, lineY ) );
        const geometry = new THREE.BufferGeometry().setFromPoints( points );
        lineGeometries.push(geometry);
      } 
      const material = new THREE.LineBasicMaterial( { 	color: 0x00ffff, linewidth: 1, } );
      for (let i = 0; i < lineGeometries.length; i++) {
        const line = new THREE.Line( lineGeometries[i], material );
        scene.add( line ); //adding each line to the scene
      } 


      //Markers
      const puckPointerGeo = new THREE.CylinderGeometry( 20, 5, 80, 8, 2 );
      const puckPointerMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true} );
      const puckPointer = new THREE.Mesh( puckPointerGeo, puckPointerMaterial );
      scene.add( puckPointer );

      const vlGroup = new THREE.Group();
      const testlocation = new Object();
      testlocation.x = 200;
      testlocation.y = 3000;
    



            //gui
      var gui = new dat.GUI();
      // gui.add(lightPoint, 'intensity', 0, 10, 0.01);
      gui.add( camera.position , 'z', -10000, 10000 ).step(10)
      gui.add( camera.position , 'x', -10000, 10000 ).step(10)
      gui.add( camera.position , 'y', -10000, 10000 ).step(10)
      gui.add( testlocation , 'y', -10000, 10000 ).step(1)
      



      //Anitmation
      function animate() {
        
        
        requestAnimationFrame( animate );

        camera.lookAt(300, -200, 1200);
        
        bp1.position.set(10000, 0, 0);
        bp2.position.set(10000, 0, 0);
        bp3.position.set(10000, 0, 0);
        bp4.position.set(10000, 0, 0);

        rp1.position.set(10000, 0, 0);
        rp2.position.set(10000, 0, 0);
        rp3.position.set(10000, 0, 0);
        rp4.position.set(10000, 0, 0);
        
        const bpBest = [];
        const rpBest = [];

        const rpxv = [];
        const rpyv = [];
        const bpxv = [];
        const bpyv = [];
        


        let bpJSON = true;
        // let bpJSON = component.bluePucks;


        if (bpJSON) {

          const bpObj = {"locations":[{"puck":[518,0,1]},{"puck":[180,220,1]},{"puck":[testlocation.x,testlocation.y,1]}]};
          // const bpObj = JSON.parse(bpJSON);

          
          
          for (let i = 0; i < bpObj.locations.length; i++) {
            var bpx = 0;
            var bpy = 0;
            bpx = bpObj.locations[i].puck[0];
            bpy = bpObj.locations[i].puck[1];
            if (i == 0){
              bp1.position.set(bpx, 10, bpy);
            }
            if (i == 1){
              bp2.position.set(bpx, 10, bpy);
            }
            if (i == 2){
              bp3.position.set(bpx, 10, bpy);
            }
            if (i == 3){
              bp4.position.set(bpx, 10, bpy);
            }
            bpxv.push(bpx);
            bpyv.push(bpy);
          } 

          //add arrow to best red shot

          const bplowY = Math.min(...bpyv);
          const bplowYindex = bpyv.indexOf(bplowY);

          const bplowX = bpxv[bplowYindex];

          bpBest.push(bplowX);
          bpBest.push(bplowY);

          
        }

       

        let rpJSON = true;
        // let rpJSON = component.redPucks;

        if (rpJSON) {
          const rpObj = {"locations":[{"puck":[468,420,1]},{"puck":[94,290,1]},{"puck":[218,1420,1]},{"puck":[40,390,1]}]};
          // const rpObj = JSON.parse(rpJSON);
        

          for (let i = 0; i < rpObj.locations.length; i++) {
            var rpx = 0;
            var rpy = 0;
            rpx = rpObj.locations[i].puck[0];
            rpy = rpObj.locations[i].puck[1];
            if (i == 0){
              rp1.position.set(rpx, 10, rpy);
            }
            if (i == 1){
              rp2.position.set(rpx, 10, rpy);
            }
            if (i == 2){
              rp3.position.set(rpx, 10, rpy);
            }
            if (i == 3){
              rp4.position.set(rpx, 10, rpy);
            }
            rpxv.push(rpx);
            rpyv.push(rpy);
          } 


          

          


          //add arrow to best red shot
          const lowY = Math.min(...rpyv);
          const lowYindex = rpyv.indexOf(lowY);

          const lowX = rpxv[lowYindex];

          rpBest.push(lowX);
          rpBest.push(lowY);
        }


        if (rpBest[1]<bpBest[1]){
          puckPointer.position.set(rpBest[0], 80, rpBest[1]);
        }

        else{
          puckPointer.position.set(bpBest[0], 80, bpBest[1]);
        }
        
        const cellObjArray = [];

        if (true){
        //veronoi

          // var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];
          // // xl, xr means x left, x right
          // // yt, yb means y top, y bottom
          // var bbox = {xl:0, xr:600, yt:0, yb:3500};
          // var voronoi = new Voronoi();
          // // pass an object which exhibits xl, xr, yt, yb properties. The bounding
          // // box will be used to connect unbound edges, and to close open cells
          // result = voronoi.compute(sites, bbox);
          // // render, further analyze, etc.

          

          var redSites = [];
          for (let i = 0; i < rpxv.length; i++) {
            redSites.push({x: rpxv[i], y: rpyv[i]});
          };

          var blueSites = [];
          for (let i = 0; i < bpxv.length; i++) {
            blueSites.push({x: bpxv[i], y: bpyv[i]});
          };

          // var redSites = [ {x: rpxv[0], y: rpyv[0]}, {x: rpxv[1], y: rpyv[1]}, {x: rpxv[2], y: rpyv[2]}, {x: rpxv[3], y: rpyv[3]} ];
          // var blueSites = [ {x: bpxv[0], y: bpyv[0]}, {x: bpxv[1], y: bpyv[1]}, {x: bpxv[2], y: bpyv[2]}, {x: bpxv[3], y: bpyv[3]} ];
          const sites = blueSites.concat(redSites);

          var voronoi = new Voronoi();
          var bbox = {xl:0, xr:600, yt:0, yb:3500};
          var diagram = voronoi.compute(sites, bbox);
          diagram.puckColour = "not-assigned";


          var voronoiLinesPoints = [];
          var voronoiLinesColors = [];
          diagram.edges.forEach(ed => { 
              voronoiLinesPoints.push(ed.va.x, 1, ed.va.y, ed.vb.x, 1, ed.vb.y, ed.va.x, 30, ed.va.y, ed.vb.x, 30, ed.vb.y);
              voronoiLinesColors.push(1, .8, .8, 1, .8, .8, 1, .8, .8, 1, .8, .8);
          });
          
          var voronoiLinesGeom = new THREE.BufferGeometry();
          voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
          voronoiLinesGeom.setAttribute("color", new THREE.Float32BufferAttribute(voronoiLinesColors, 3));
          var voronoiLinesMat = new THREE.LineBasicMaterial({vertexColors: true});
          var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
    
          // const vlGroup = new THREE.Group();



          
          vlGroup.remove(...vlGroup.children);
          vlGroup.add( voronoiLines );

          scene.add( vlGroup );


          diagram.cells.forEach(cell => {
            //check red or blue
            //red
            if (rpxv.includes(cell.site.x)){
              i = rpxv.indexOf(cell.site.x)
              if (rpyv[i] === cell.site.y){
                cell.puckColour = "red";
              };
            };

            //blue
            if (bpxv.includes(cell.site.x)){
              i = bpxv.indexOf(cell.site.x)
              if (bpyv[i] === cell.site.y){
                cell.puckColour = "blue";

              };
            };

            const cellSegs = [];
            const cellId = cell.site.voronoiId;
            const cellCenter = cell.site; //{x: 218, y: 1420, voronoiId: 4}

            cell.halfedges.forEach(halfedge => {
              const edge = halfedge.edge;
              const edgeVa = edge.va; //{x: 0, y: 1613.8425531914893}
              const edgeVb = edge.vb; //{x: 600, y: 1772.1404255319148}
              // console.log(edgeVa);
              // console.log(edgeVb);
              const aX = edgeVa.x;
              const aY = edgeVa.y;
              const bX = edgeVb.x;
              const bY = edgeVb.y;
              const cX = cellCenter.x;
              const cY = cellCenter.y;
              // console.log(
              // "aX = " + aX ,
              // "aY = " + aY ,
              // "bX = " + bX ,
              // "bY = " + bY ,
              // "cX = " + cX ,
              // "cY = " + cY ,);
              const segArea = (aX * (bY - cY) + bX * (cY - aY) + cX * (aY - bY))/2
              const segAreaPositive = Math.abs(segArea);
              cellSegs.push(segAreaPositive);

            });

            const cellArea = cellSegs.reduce((a, b) => a + b, 0);

            const cellObj = new Object();
            cellObj.voronoiId = cellId;
            cellObj.area = cellArea;
            cellObj.site = cellCenter;
            cellObj.colour = cell.puckColour;
            cellObjArray.push(cellObj);
          });
          
          

        }

        console.log("---------areas calculated-------------")
        console.log( "cellObjArray = ", cellObjArray)




        //Total area
        const cellAreaArray = []

        cellObjArray.forEach((element, index, array) => {
          cellAreaArray.push(element.area);
        });

        const totalArea = cellAreaArray.reduce((a, b) => a + b, 0);
        console.log( "totalArea = ", totalArea)

        //Blue and red area
        const redAreaArray = [];
        const blueAreaArray = [];

        cellObjArray.forEach((element, index, array) => {
          if ( element.colour === "blue" ){
            blueAreaArray.push(element.area);
          }
          if ( element.colour === "red" ){
            redAreaArray.push(element.area);
          }
          
        });


        const redArea = redAreaArray.reduce((a, b) => a + b, 0);;
        const blueArea = blueAreaArray.reduce((a, b) => a + b, 0);;


        const bluePercent = blueArea / totalArea * 100;
        const redPercent = redArea / totalArea * 100;

        console.log("blue % = ", bluePercent);
        console.log("red % = ", redPercent);

          //Add colour

          //Area as a percentage
          //Display percentage


        renderer.render( scene, camera );
      }
      animate();

		</script>
	</body>
</html>