<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>
    <script src="js/rhill-voronoi-core.js"></script>

    <div id=container style="width: 100%; height: 100vh">
      <div id="scene" style="
      width: 100%;
      height: 100%">
      </div>

    </div>
		<script>



      
      // Our Javascript will go here.
      const scene = new THREE.Scene();

 
      //Add Renderer
      const renderer = new THREE.WebGLRenderer();
      var container = document.getElementById('scene');
      var w = container.offsetWidth;
      var h = container.offsetHeight;
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);
      
      

      //Camera
      const camera = new THREE.PerspectiveCamera( 60, w / h, 0.1, 10000 );
      camera.position.x = 1000;
      camera.position.y = 1000;
      camera.position.z = -500;

      //controls
      var controls = new THREE.OrbitControls(camera, container);

      //Lights
      const lightAmb = new THREE.AmbientLight( 0x404040, 1 ); // soft white light
      const lightPoint = new THREE.PointLight( 0xffffff, 2, 100000, 2 );

      scene.add( lightPoint );
      lightPoint.position.set( -1000, 550, -2250 );

      scene.add( lightAmb );

      

      //Table
      const tableGeometry = new THREE.BoxGeometry( 600, 100, 4500, 10, 2, 60  );
      const tableCoreGeometry = new THREE.BoxGeometry( 598, 98, 4498 );

      const tableCoreMat = new THREE.MeshPhongMaterial( {color: 0x000000} );
      const tableMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true} );

      const tableCore = new THREE.Mesh( tableCoreGeometry, tableCoreMat );
      const tableOuter = new THREE.Mesh( tableGeometry, tableMaterial );

      scene.add( tableOuter, tableCore );

      tableOuter.position.set(300, -50, 2250);
      tableCore.position.set(299, -50, 2249);




      //Pucks
      const puckCylinder = new THREE.CylinderGeometry( 30, 30, 20, 8, 2 );
      const puckCoreCylinder = new THREE.CylinderGeometry( 28, 28, 18, 8, 2 );

      //Red Puck
      const rpMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, wireframe: true} );
      const rpCoreMat = new THREE.MeshPhongMaterial( {color: 0xfc0352} );
      //Create Red Pucks
      var rp1 = new THREE.Group();
      var rp2 = new THREE.Group();
      var rp3 = new THREE.Group();
      var rp4 = new THREE.Group();
      const allRedPucks = [rp1, rp2, rp3, rp4];
      for (let i = 0; i < allRedPucks.length; i++) {
        allRedPucks[i].add( new THREE.Mesh( puckCylinder, rpMaterial ) );
        allRedPucks[i].add( new THREE.Mesh( puckCoreCylinder, rpCoreMat ) );
      }

        

      //Blue Puck
      const bpMaterial = new THREE.MeshBasicMaterial( {color: 0x03b1fc, wireframe: true} );
      const bpCoreMat = new THREE.MeshPhongMaterial( {color: 0x03b1fc} );
      //create Blue Pucks
      var bp1 = new THREE.Group();
      var bp2 = new THREE.Group();
      var bp3 = new THREE.Group();
      var bp4 = new THREE.Group();
      const allBluePucks = [bp1, bp2, bp3, bp4];
      for (let i = 0; i < allBluePucks.length; i++) {
        allBluePucks[i].add( new THREE.Mesh( puckCylinder, bpMaterial ) );
        allBluePucks[i].add( new THREE.Mesh( puckCoreCylinder, bpCoreMat ) );
      }



      const allPucks = allBluePucks.concat(allRedPucks);
      for (let i = 0; i < allPucks.length; i++) {
        scene.add(allPucks[i]);
        allPucks[i].position.set(10000, 0, 0);
      }




      //Lines
      const scoreLines = [60,165,524,1054,1768,2762]; // y value of lines
      const lineGeometries = [];
      for (let i = 0; i < scoreLines.length; i++) {
        const points = [];
        const lineY = scoreLines[i];
        points.push( new THREE.Vector3( 0, 1, lineY ) );
        points.push( new THREE.Vector3( 600, 1, lineY ) );
        const geometry = new THREE.BufferGeometry().setFromPoints( points );
        lineGeometries.push(geometry);
      } 
      const material = new THREE.LineBasicMaterial( { 	color: 0x00ffff } );
      for (let i = 0; i < lineGeometries.length; i++) {
        const line = new THREE.Line( lineGeometries[i], material );
        scene.add( line ); //adding each line to the scene
      } 


      //Markers
      const puckPointerGeo = new THREE.CylinderGeometry( 20, 5, 80, 8, 2 );
      const puckPointerMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true} );
      const puckPointer = new THREE.Mesh( puckPointerGeo, puckPointerMaterial );
      scene.add( puckPointer );


      //Scene






      //gui
      var gui = new dat.GUI();
      gui.add(lightPoint, 'intensity', 0, 10, 0.01);
      gui.add( camera.position , 'z', -10000, 10000 ).step(10)
      gui.add( camera.position , 'x', -10000, 10000 ).step(10)
      gui.add( camera.position , 'y', -10000, 10000 ).step(10)








      //Anitmation
      function animate() {
        
        
        requestAnimationFrame( animate );

        camera.lookAt(300, -200, 1200);
        
        bp1.position.set(10000, 0, 0);
        bp2.position.set(10000, 0, 0);
        bp3.position.set(10000, 0, 0);
        bp4.position.set(10000, 0, 0);

        rp1.position.set(10000, 0, 0);
        rp2.position.set(10000, 0, 0);
        rp3.position.set(10000, 0, 0);
        rp4.position.set(10000, 0, 0);
        
        const bpBest = [];
        const rpBest = [];
        


        let bpJSON = true;
        // let bpJSON = component.bluePucks;

        if (bpJSON) {
          // const bpObj = JSON.parse(bpJSON);
          const bpObj = {"locations":[{"puck":[518,10,1]},{"puck":[238,820,1]},{"puck":[180,220,1]},{"puck":[94,1890,1]}]};

          const bpxv = [];
          const bpyv = [];
          
          for (let i = 0; i < bpObj.locations.length; i++) {
            var bpx = 0;
            var bpy = 0;
            bpx = bpObj.locations[i].puck[0];
            bpy = bpObj.locations[i].puck[1];
            if (i == 0){
              bp1.position.set(bpx, 10, bpy);
            }
            if (i == 1){
              bp2.position.set(bpx, 10, bpy);
            }
            if (i == 2){
              bp3.position.set(bpx, 10, bpy);
            }
            if (i == 3){
              bp4.position.set(bpx, 10, bpy);
            }
            bpxv.push(bpx);
            bpyv.push(bpy);
          } 

          //add arrow to best red shot
          console.log(bpyv);
          const bplowY = Math.min(...bpyv);
          const bplowYindex = bpyv.indexOf(bplowY);

          const bplowX = bpxv[bplowYindex];
          // console.log(bplowX);
          // console.log(bplowY);
          bpBest.push(bplowX);
          bpBest.push(bplowY);

          
        }

        let rpJSON = true;
        // let rpJSON = component.redPucks;

        if (rpJSON) {
          // const rpObj = JSON.parse(rpJSON);
          const rpObj = {"locations":[{"puck":[468,420,1]},{"puck":[218,1420,1]},{"puck":[40,390,1]}]};

          const rpxv = [];
          const rpyv = [];

          for (let i = 0; i < rpObj.locations.length; i++) {
            var rpx = 0;
            var rpy = 0;
            rpx = rpObj.locations[i].puck[0];
            rpy = rpObj.locations[i].puck[1];
            if (i == 0){
              rp1.position.set(rpx, 10, rpy);
            }
            if (i == 1){
              rp2.position.set(rpx, 10, rpy);
            }
            if (i == 2){
              rp3.position.set(rpx, 10, rpy);
            }
            if (i == 3){
              rp4.position.set(rpx, 10, rpy);
            }
            rpxv.push(rpx);
            rpyv.push(rpy);
          } 


          //veronoi

          // var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];
          // // xl, xr means x left, x right
          // // yt, yb means y top, y bottom
          // var bbox = {xl:0, xr:600, yt:0, yb:3500};
          // var voronoi = new Voronoi();
          // // pass an object which exhibits xl, xr, yt, yb properties. The bounding
          // // box will be used to connect unbound edges, and to close open cells
          // result = voronoi.compute(sites, bbox);
          // // render, further analyze, etc.


          var sites = [ {x: 200, y: 200}, {x: 50, y: 250}, {x: 400, y: 100} ];







          var voronoi = new Voronoi();
          var bbox = {xl:0, xr:600, yt:0, yb:3500};
          var diagram = voronoi.compute(sites, bbox);
          console.log(sites);

          var voronoiPoints = diagram.vertices;
          var voronoiPointsGeom = new THREE.BufferGeometry().setFromPoints(voronoiPoints);
          var voronoiPointsMat = new THREE.PointsMaterial({color: "magenta", size: 3});
          var voronoiPoints = new THREE.Points(voronoiPointsGeom, voronoiPointsMat);
          scene.add(voronoiPoints);

          var voronoiLinesPoints = [];
          var voronoiLinesColors = [];
          diagram.edges.forEach(ed => { 
              voronoiLinesPoints.push(ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0, ed.va.x, ed.va.y, 10, ed.vb.x, ed.vb.y, 10);
              voronoiLinesColors.push(1, 1, 0, 1, 1, 0, 0, 0.25, 0.25, 0, 0.25, 0.25);
          });
          var voronoiLinesGeom = new THREE.BufferGeometry();
          voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
          voronoiLinesGeom.setAttribute("color", new THREE.Float32BufferAttribute(voronoiLinesColors, 3));
          var voronoiLinesMat = new THREE.LineBasicMaterial({vertexColors: true});
          var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
          scene.add(voronoiLines);

          

          // console.log(result)



          //add arrow to best red shot
          console.log(rpyv);
          const lowY = Math.min(...rpyv);
          const lowYindex = rpyv.indexOf(lowY);

          const lowX = rpxv[lowYindex];

          rpBest.push(lowX);
          rpBest.push(lowY);

          
          // console.log(lowX);
          // console.log(lowY);

        }
        console.log(rpBest);
        console.log(bpBest);

        if (rpBest[1]<bpBest[1]){
          puckPointer.position.set(rpBest[0], 80, rpBest[1]);
        }

        else{
          puckPointer.position.set(bpBest[0], 80, bpBest[1]);
        }


        

        renderer.render( scene, camera );
      }
      animate();

		</script>
	</body>
</html>