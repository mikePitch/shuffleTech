<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="js/rhill-voronoi-core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js" type="text/javascript"></script>

    <div id=container style="width: 100%; height: 100vh">
      <div id="scene" style="
      width: 100%;
      height: 100%">
      </div>

    </div>


		<script>
      
      

      const backendless = false;

      //game type
      const gameType = new Object();
      gameType.neoShuffle = false;
      gameType.classicShuffle = true;
      gameType.spaceInvaders = false;
      gameType.blackJack = true;
      gameType.neoCurling = true;

      

      
      // Our Javascript will go here.
      const scene = new THREE.Scene();


     
      

      
 
      //Add Renderer
      const renderer = new THREE.WebGLRenderer();
      var container = document.getElementById('scene');
      var w = container.offsetWidth;
      var h = container.offsetHeight;
      renderer.setSize(w, h);
      renderer.setPixelRatio( window.devicePixelRatio );
      container.appendChild(renderer.domElement);


      //Background
      

      //cubemap
      scene.background = new THREE.CubeTextureLoader()
      // .setPath( '/api/files/Images/threejs/textures/cubeMaps/' )
      .setPath( 'textures/cubeMaps/' )
      .load( [
        'nx.jpeg',
        'px.jpeg',
        'py.jpeg',
        'ny.jpeg',
        'pz.jpeg',
        'nz.jpeg'
      ] );
      // .setPath( 'textures/cubeMaps/synthwave/' )
      // .load( [
      //   'lft.png',
      //   'rht.png',
      //   'top.png',
      //   'btm.png',
      //   'fnt.png',
      //   'bck.png'
      // ] );
      

      //Camera
      

      //---- 3DPerspective ----
      const camera = new THREE.PerspectiveCamera( 60, w / h, 0.1, 10000 );
      camera.position.x = 1000;
      camera.position.y = 1000;
      camera.position.z = -500;

      // //---- Isometric Perspective ----
      // scene.rotation.y = -90 * Math.PI/180;
      // var aspect = window.innerWidth / window.innerHeight;
      // var d = 1400;
      // const camera = new THREE.OrthographicCamera( - d * aspect, d * aspect, d, - d, 1, 100000 );
      // camera.position.set( 2000, 2000, 2000 );
      // camera.lookAt( scene.position ); // or the origin
      

      if (backendless === false){
      //controls
        var controls = new THREE.OrbitControls(camera, container);
      }

      // camera.position.set( -250, 2000, 2140 );

      

      //Lights
      const lightAmb = new THREE.AmbientLight( 0x404040, 2.5 ); // soft white light
      // const lightPoint = new THREE.PointLight( 0xffffff, .8, 0, 2 );

      scene.add( lightAmb );




      const lightGeometry = new THREE.SphereGeometry( 5, 32, 16 );
      const lightMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff} );
      // const lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );

      //table lights
      const numLights = 5;
      const lightsDist = 1000

      for (let i = 0; i < numLights; i++) {
        const lightPoint = new THREE.PointLight( 0xffffff, 2.2, 1200, 2 );
        const lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );
        lightPoint.position.set( 300, 600, i*lightsDist-600 );
        lightMesh.position.set( 300, 600, i*lightsDist );
        scene.add( lightMesh );
        scene.add( lightPoint );
      }





      // lightPoint.position.set( 300, 800, 3000 );
      // lightMesh.position.set( 300, 800, 3000 );

      

      //Table
      const tableGeometry = new THREE.BoxGeometry( 600, 100, 4500 );
      const tableCoreGeometry = new THREE.BoxGeometry( 598, 98, 4498 );

      const tableCoreMat = new THREE.MeshPhongMaterial( {color: 0x250b52} );
      const tableMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true} );

      const tableCore = new THREE.Mesh( tableCoreGeometry, tableCoreMat );
      const tableOuter = new THREE.Mesh( tableGeometry, tableCoreMat );

      scene.add( tableOuter, tableCore );

      tableOuter.position.set(300, -50, 2250);
      tableCore.position.set(299, -50, 2249);




      //Pucks
      const puckCylinder = new THREE.CylinderGeometry( 30, 30, 20, 16, 1 );
      const puckCoreCylinder = new THREE.CylinderGeometry( 28, 28, 18, 16, 1 );

      //Red Puck
      const rpMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, wireframe: true} );
      const rpCoreMat = new THREE.MeshPhongMaterial( {color: 0xfc0352} );
      //Create Red Pucks
      var rp1 = new THREE.Group();
      var rp2 = new THREE.Group();
      var rp3 = new THREE.Group();
      var rp4 = new THREE.Group();
      const allRedPucks = [rp1, rp2, rp3, rp4];
      for (let i = 0; i < allRedPucks.length; i++) {
        // allRedPucks[i].add( new THREE.Mesh( puckCylinder, rpMaterial ) );
        allRedPucks[i].add( new THREE.Mesh( puckCoreCylinder, rpCoreMat ) );
      }

        

      //Blue Puck
      const bpMaterial = new THREE.MeshBasicMaterial( {color: 0x03b1fc, wireframe: true} );
      const bpCoreMat = new THREE.MeshPhongMaterial( {color: 0x03b1fc} );
      //create Blue Pucks
      var bp1 = new THREE.Group();
      var bp2 = new THREE.Group();
      var bp3 = new THREE.Group();
      var bp4 = new THREE.Group();
      const allBluePucks = [bp1, bp2, bp3, bp4];
      for (let i = 0; i < allBluePucks.length; i++) {
        // allBluePucks[i].add( new THREE.Mesh( puckCylinder, bpMaterial ) );
        allBluePucks[i].add( new THREE.Mesh( puckCoreCylinder, bpCoreMat ) );
      }

      const allPucks = allBluePucks.concat(allRedPucks);
      for (let i = 0; i < allPucks.length; i++) {
        scene.add(allPucks[i]);
        allPucks[i].position.set(10000, 0, 0);
      }



      var voronoiLinesMat = new THREE.LineBasicMaterial({color: 0x9f9fff});


      const vlGroup = new THREE.Group();



      const bpLocation = new Object();
      bpLocation.x = 100;
      bpLocation.y = 3000;

      const rpLocation = new Object();
      rpLocation.x = 400;
      rpLocation.y = 3080;
    



            //gui
      var gui = new dat.GUI();
      // gui.add(lightPoint, 'intensity', 0, 10, 0.01);
      gui.add( camera.position , 'z', -10000, 10000 ).step(10);
      gui.add( camera.position , 'x', -10000, 10000 ).step(10);
      gui.add( camera.position , 'y', -10000, 10000 ).step(10);
      var bluetestpuck = gui.addFolder('Blue Test Puck');
      bluetestpuck.add( bpLocation , 'y', 0, 4500 ).step(1);
      bluetestpuck.add( bpLocation , 'x', 0, 600 ).step(1);
      var redtestpuck = gui.addFolder('Red Test Puck');
      redtestpuck.add( rpLocation , 'y', 0, 4500 ).step(1);
      redtestpuck.add( rpLocation , 'x', 0, 600 ).step(1);

      



      // ------------Game Specific UI-----------

      // ---Space Invaders---

      //bar Chart
      const barBaseX = 50;
      const barHeight = 1;
      const barBaseY = 50;
      const bpBarWFMaterial = new THREE.MeshBasicMaterial( {color: 0x03b1fc, wireframe: true} );
      const bpBarMat = new THREE.MeshPhongMaterial( {color: 0x03b1fc} );
      const rpBarMat = new THREE.MeshPhongMaterial( {color: 0xfc0352} );
      const barBlueGeometry = new THREE.BoxGeometry( barBaseX, barHeight, barBaseY );
      const barRedGeometry = new THREE.BoxGeometry( barBaseX, barHeight, barBaseY );
      barRedGeometry.translate( 0, barHeight/2 , 0 );
      barBlueGeometry.translate( 0, barHeight/2 , 0 );
      const bpBar = new THREE.Mesh( barBlueGeometry, bpBarMat );
      const rpBar = new THREE.Mesh( barRedGeometry, rpBarMat );

      if (gameType.spaceInvaders){
        scene.add( bpBar, rpBar );
        bpBar.position.set(-50, 0, 0);
        rpBar.position.set(-50, 0, 50);
      };

      // ---Classic Shuffle---

      //Lines

      if (gameType.classicShuffle || gameType.neoShuffle){

        const scoreLines = [60,165,524,1054,1768,2762]; // y value of lines
        const lineGeometries = [];
        for (let i = 0; i < scoreLines.length; i++) {
          const points = [];
          const lineY = scoreLines[i];
          points.push( new THREE.Vector3( 0, 1, lineY ) );
          points.push( new THREE.Vector3( 600, 1, lineY ) );
          const geometry = new THREE.BufferGeometry().setFromPoints( points );
          lineGeometries.push(geometry);
        } 
          const material = new THREE.LineBasicMaterial( { 	color: 0x00ffff, linewidth: 1, } );
          for (let i = 0; i < lineGeometries.length; i++) {
            const line = new THREE.Line( lineGeometries[i], material );
            scene.add( line ); //adding each line to the scene
          }; 
      };
      
      //Markers
      const puckPointerGeo = new THREE.CylinderGeometry( 20, 5, 20, 8, 2 );
      const puckPointerMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true} );
      const puckPointer = new THREE.Mesh( puckPointerGeo, puckPointerMaterial );
      scene.add( puckPointer );
      puckPointer.position.set(10000,10000,10000);

      const scoringPuckGeo = new THREE.CircleGeometry( 50, 8 );
      const scoringPuckIndicatorsGrp = new THREE.Group();


      //------curling----------
      const curlingCenter = {x: 300, y: 789};
      console.log("curling center x = ", curlingCenter.x, "curling center y = ", curlingCenter.y)
      const curlingCircGeo1 = new THREE.CircleGeometry( 150
      , 36 );
      const curlingCircMat1 = new THREE.MeshPhongMaterial( {color: 0x00ffff, wireframe: true} );
      const curlingCircGeo2 = new THREE.CircleGeometry( 20, 56 );
      const curlingCircMat2 = new THREE.MeshPhongMaterial( {color: 0x250b52, side: THREE.DoubleSide} );
      const curlingCircleMesh1 = new THREE.Mesh( curlingCircGeo1, curlingCircMat1 );
      const curlingCircleMesh2 = new THREE.Mesh( curlingCircGeo2, curlingCircMat2 );

      const curlingCircles = new THREE.Group();

      curlingCircles.add( curlingCircleMesh1, curlingCircleMesh2 );
      scene.add( curlingCircles );
      curlingCircles.position.set( curlingCenter.x, 1, curlingCenter.y);
      curlingCircleMesh2.position.set( 0, 0, -2);
      curlingCircles.rotation.x = Math.PI / 2;





      



      //Anitmation
      function animate() {
        
        
        requestAnimationFrame( animate );

        // -----3d Perspective-----
        camera.lookAt(300, -200, 1200);

        
        

        
        
        
        bp1.position.set(10000, 0, 0);
        bp2.position.set(10000, 0, 0);
        bp3.position.set(10000, 0, 0);
        bp4.position.set(10000, 0, 0);

        rp1.position.set(10000, 0, 0);
        rp2.position.set(10000, 0, 0);
        rp3.position.set(10000, 0, 0);
        rp4.position.set(10000, 0, 0);
        
        const bpBest = [];
        const rpBest = [];

        const rpxv = [];
        const rpyv = [];
        const bpxv = [];
        const bpyv = [];
        


        let bpJSON = true;
        // let bpJSON = component.bluePucks;


        if (bpJSON) {

          const bpObj = {"locations":[{"puck":[bpLocation.x,bpLocation.y,1]},{"puck":[518,1231,1]},{"puck":[180,220,1]}]};
          // const bpObj = JSON.parse(bpJSON);

          
          
          for (let i = 0; i < bpObj.locations.length; i++) {
            var bpx = 0;
            var bpy = 0;
            bpx = bpObj.locations[i].puck[0];
            bpy = bpObj.locations[i].puck[1];
            if (i == 0){
              bp1.position.set(bpx, 10, bpy);
            }
            if (i == 1){
              bp2.position.set(bpx, 10, bpy);
            }
            if (i == 2){
              bp3.position.set(bpx, 10, bpy);
            }
            if (i == 3){
              bp4.position.set(bpx, 10, bpy);
            }
            bpxv.push(bpx);
            bpyv.push(bpy);
          } 

          //add arrow to best red shot

          const bplowY = Math.min(...bpyv);
          const bplowYindex = bpyv.indexOf(bplowY);

          const bplowX = bpxv[bplowYindex];

          bpBest.push(bplowX);
          bpBest.push(bplowY);

          
        }

       

        let rpJSON = true;
        // let rpJSON = component.redPucks;

        if (rpJSON) {
          const rpObj = {"locations":[{"puck":[rpLocation.x,rpLocation.y,1]},{"puck":[584,690,1]}]};
          // const rpObj = JSON.parse(rpJSON);
        

          for (let i = 0; i < rpObj.locations.length; i++) {
            var rpx = 0;
            var rpy = 0;
            rpx = rpObj.locations[i].puck[0];
            rpy = rpObj.locations[i].puck[1];
            if (i == 0){
              rp1.position.set(rpx, 10, rpy);
            }
            if (i == 1){
              rp2.position.set(rpx, 10, rpy);
            }
            if (i == 2){
              rp3.position.set(rpx, 10, rpy);
            }
            if (i == 3){
              rp4.position.set(rpx, 10, rpy);
            }
            rpxv.push(rpx);
            rpyv.push(rpy);
          } 


          //add arrow to best red shot
          const lowY = Math.min(...rpyv);
          const lowYindex = rpyv.indexOf(lowY);

          const lowX = rpxv[lowYindex];

          rpBest.push(lowX);
          rpBest.push(lowY);
        }


        if (gameType.neoCurling){
          

        }


        if (gameType.classicShuffle){
        scoringPuckIndicatorsGrp.remove(...scoringPuckIndicatorsGrp.children);


        if (rpBest[1]<bpBest[1]){
          puckPointer.position.set(rpBest[0], 50, rpBest[1]);
          rpyv.forEach(function(e, i, a) {
            if (rpyv[i]<bpBest[1]){
            const scoringPuckIndicators = new THREE.Mesh( scoringPuckGeo, puckPointerMaterial );
            scoringPuckIndicators.position.set(rpxv[i], 3, rpyv[i]);
            scoringPuckIndicators.rotation.x = Math.PI / 2;
            scoringPuckIndicatorsGrp.add( scoringPuckIndicators );
            }
          });
          scene.add( scoringPuckIndicatorsGrp );
        }

        else{
          puckPointer.position.set(bpBest[0], 50, bpBest[1]);
          bpyv.forEach(function(e, i, a) {
            if (bpyv[i]<rpBest[1]){
            const scoringPuckIndicators = new THREE.Mesh( scoringPuckGeo, puckPointerMaterial );
            scoringPuckIndicators.position.set(bpxv[i], 3, bpyv[i]);
            scoringPuckIndicators.rotation.x = Math.PI / 2;
            scoringPuckIndicatorsGrp.add( scoringPuckIndicators );
            }
          });
          scene.add( scoringPuckIndicatorsGrp );
        };
      };
        




        //----------spaceinvades start------------------------


        if (gameType.spaceInvaders){
          const cellObjArray = [];
          console.log("spaceInvaders = ", gameType.spaceInvaders)
        //veronoi

          // var sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:600,y:150}];
          // // xl, xr means x left, x right
          // // yt, yb means y top, y bottom
          // var bbox = {xl:0, xr:600, yt:0, yb:3500};
          // var voronoi = new Voronoi();
          // // pass an object which exhibits xl, xr, yt, yb properties. The bounding
          // // box will be used to connect unbound edges, and to close open cells
          // result = voronoi.compute(sites, bbox);
          // // render, further analyze, etc.

          

          var redSites = [];
          for (let i = 0; i < rpxv.length; i++) {
            redSites.push({x: rpxv[i], y: rpyv[i]});
          };

          var blueSites = [];
          for (let i = 0; i < bpxv.length; i++) {
            blueSites.push({x: bpxv[i], y: bpyv[i]});
          };

          // var redSites = [ {x: rpxv[0], y: rpyv[0]}, {x: rpxv[1], y: rpyv[1]}, {x: rpxv[2], y: rpyv[2]}, {x: rpxv[3], y: rpyv[3]} ];
          // var blueSites = [ {x: bpxv[0], y: bpyv[0]}, {x: bpxv[1], y: bpyv[1]}, {x: bpxv[2], y: bpyv[2]}, {x: bpxv[3], y: bpyv[3]} ];
          const sites = blueSites.concat(redSites);

          var voronoi = new Voronoi();
          var bbox = {xl:0, xr:600, yt:0, yb:3500};
          var diagram = voronoi.compute(sites, bbox);
          diagram.puckColour = "not-assigned";


          var voronoiLinesPoints = [];
          var voronoiLinesColors = [];
          diagram.edges.forEach(ed => { 
              voronoiLinesPoints.push(ed.va.x, 1, ed.va.y, ed.vb.x, 1, ed.vb.y, ed.va.x, 30, ed.va.y, ed.vb.x, 30, ed.vb.y);
              voronoiLinesColors.push(1, .8, .8, 1, .8, .8, 1, .8, .8, 1, .8, .8);
          });
          
          var voronoiLinesGeom = new THREE.BufferGeometry();
          voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
          // voronoiLinesGeom.setAttribute("color", new THREE.Float32BufferAttribute(voronoiLinesColors, 3));
          var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
    
          // const vlGroup = new THREE.Group();



          
          vlGroup.remove(...vlGroup.children);
          vlGroup.add( voronoiLines );

          scene.add( vlGroup );


          // for (let i = 0; i < diagram.cells.length; i++) {
          //   const cell = diagram.cells[i];
          //   console.log("cell2 = ", cell);
          //   console.log("cell2 x = ", cell.site.x);
          // };

          console.log ("test  =",diagram.cells.length);



       
          diagram.cells.forEach(function(cell, i, a) {
            console.log("cell = ", cell);
            console.log("cell x = ", cell.site.x);
            //check red or blue
            //red
            if (rpxv.includes(cell.site.x)){
              i = rpxv.indexOf(cell.site.x)
              if (rpyv[i] === cell.site.y){
                cell.puckColour = "red";
              };
            };

            //blue
            if (bpxv.includes(cell.site.x)){
              i = bpxv.indexOf(cell.site.x)
              if (bpyv[i] === cell.site.y){
                cell.puckColour = "blue";

              };
            };

            const cellSegs = [];
            const cellId = cell.site.voronoiId;
            const cellCenter = cell.site; //{x: 218, y: 1420, voronoiId: 4}

            cell.halfedges.forEach(halfedge => {
              const edge = halfedge.edge;
              const edgeVa = edge.va; //{x: 0, y: 1613.8425531914893}
              const edgeVb = edge.vb; //{x: 600, y: 1772.1404255319148}
              // console.log(edgeVa);
              // console.log(edgeVb);
              const aX = edgeVa.x;
              const aY = edgeVa.y;
              const bX = edgeVb.x;
              const bY = edgeVb.y;
              const cX = cellCenter.x;
              const cY = cellCenter.y;
              // console.log(
              // "aX = " + aX ,
              // "aY = " + aY ,
              // "bX = " + bX ,
              // "bY = " + bY ,
              // "cX = " + cX ,
              // "cY = " + cY ,);
              const segArea = (aX * (bY - cY) + bX * (cY - aY) + cX * (aY - bY))/2
              const segAreaPositive = Math.abs(segArea);
              cellSegs.push(segAreaPositive);

            });

            const cellArea = cellSegs.reduce((a, b) => a + b, 0);

            const cellObj = new Object();
            cellObj.voronoiId = cellId;
            cellObj.area = cellArea;
            cellObj.site = cellCenter;
            cellObj.colour = cell.puckColour;
            cellObjArray.push(cellObj);
          });
          
          

        

          console.log("---------areas calculated-------------")
          console.log( "cellObjArray = ", cellObjArray)




          //Total area
          const cellAreaArray = []

          cellObjArray.forEach((element, index, array) => {
            cellAreaArray.push(element.area);
          });

          const totalArea = cellAreaArray.reduce((a, b) => a + b, 0);
          console.log( "totalArea = ", totalArea)

          //Blue and red area
          const redAreaArray = [];
          const blueAreaArray = [];

          cellObjArray.forEach((element, index, array) => {
            if ( element.colour === "blue" ){
              blueAreaArray.push(element.area);
            }
            if ( element.colour === "red" ){
              redAreaArray.push(element.area);
            }
            
          });


          const redArea = redAreaArray.reduce((a, b) => a + b, 0);;
          const blueArea = blueAreaArray.reduce((a, b) => a + b, 0);;


          const bluePercent = blueArea / totalArea * 100;
          const redPercent = redArea / totalArea * 100;

          console.log("blue % = ", bluePercent);
          console.log("red % = ", redPercent);

          rpBar.scale.y = redPercent*5;
          bpBar.scale.y = bluePercent*5;

          const barRedHeight = redPercent*5;
          const barBlueHeight = bluePercent*5;
        }

        //----------spaceinvades end-------------------------

      

        renderer.render( scene, camera );
      }
      animate();

		</script>
	</body>
</html>